<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Radical Javascript</title>

    <link rel="shortcut icon" href="favicon.png">
  
    <link rel="stylesheet" href="reveal/css/reveal.min.css">
    <link rel="stylesheet" href="reveal/lib/css/github.css">

    <link rel="stylesheet" href="slides-theme/style.css" id="theme">
    <link rel="stylesheet" href="slides-theme/talk-specific.css" id="theme">

    <link rel="stylesheet" href="slides-theme/js/little-console.css" id="theme">
</head>

<body>

<div class="reveal">
<div class="slides">


<section data-markdown><script type="text/template">
# Radical Javascript
[@timruffles](http://twitter.com/timruffles)
</script></section>


<section data-markdown><script type="text/template">
## Variables

```javascript
var x = "howdy";
var iAmUnitialized; // note: JS is camelCase

// messy version-control diffs
var x = "howdy",
    iAmUnitialized;

// oh god why?
var x = "howdy", iAmUnitialized, y = 1, p,
    readingThisMakesYouWonderIfItWasPreminified = true, pp = {},
    someOtherVariable; 
```
</script></section>

<section data-markdown><script type="text/template">
## Suggested

```javascript
var camelCase = "standard: matches JS's own APIs";
var oneVarPerLine = "neat diffs";
```

Avoids non-local version-control changes:

```sh
  var x = 1,
-     y = 2;
+     y = 2,
+     z = 3;
```

</script></section>

<section data-markdown><script type="text/template">
## Scope is ONLY affected by functions
</script></section>

<section data-markdown><script type="text/template">
## Variables

```javascript
function sayHi(to,greeting,times) {
  var i = times;
  while(i--) {
    console.log("%s %s",greeting,to);
  }
}

var greeting;
var i = 100;

sayHi("bob", "hello", 50);
```
</script></section>

<section data-markdown><script type="text/template">
## `var` is not block scoped

```javascript
// all refer to same 'i', it will end up as 50 or 20
var i = 10;

if(x) {
  var i = 50;
} else {
  var i = 20;
}
```
</script></section>



<section data-markdown><script type="text/template">
## `undefined` vs undeclared
</script></section>

<section data-markdown><script type="text/template">

```javascript
// Uncaught ReferenceError: start is not defined
start();
```

```javascript
var start;
// TypeError: undefined is not a function
start();
```
</script></section>

<section data-markdown><script type="text/template">
## `undefined` is a value

- `undefined` is a value of a variable
- undeclared is a state of a variable in a scope
</script></section>

<section data-markdown><script type="text/template">
## `undefined`

- placeholder value for uninitialised variables
- or arguments not provided in a function

```javascript
function hi(x) {
  console.log('hi ' + x);
}

// 'hi undefined'
hi();
```
</script></section>


<section data-markdown><script type="text/template">
## Always declare with var
</script></section>


<section data-markdown><script type="text/template">
## Avoid creating global variables

```javascript
function A(arg) {
  x = arg;
}
function B(arg) {
  var x = arg;
}

// x; // would be 'ReferenceError: x is not defined'

A("hello");
console.log( x ); // hello
console.log( window.x ); // hello

// has not affected/created global
B("bye");
console.log( x ); // hello
```
</script></section>


<section data-markdown><script type="text/template">
## Hoisting

What happens?

```javascript
console.log(greeting);
var greeting = "hello";
```
</script></section>

<section data-markdown><script type="text/template">
## Hoisting, part II

What happens?

```javascript
sayHi();

function sayHi() {
  console.log("Hello");
}
```
</script></section>

<section data-markdown><script type="text/template">
## `var` hoisting

- hoisted to top of enclosing scope (function)
- has value of `undefined` until assigned a value

</script></section>

<section data-markdown><script type="text/template">
## Function declaration hoisting

- hoisted to top of enclosing scope (function)
- is initialised as function throughout scope

</script></section>


<section data-markdown><script type="text/template">
## Benefits: readability

```javascript
// reads high-level to low-level: important stuff first
function main() {
  interestingHighLevelTaskA();
  interestingHighLevelTaskB();
}
function interestingHighLevelTaskA() {
  boringFiddlyHelper();
}
function interestingHighLevelTaskB() {
  moreImplementationDetails();
}
function boringFiddlyHelper() {
}
function moreImplementationDetails() {
}
```
</script></section>

<section data-markdown><script type="text/template">
## Benefits: locality

```javascript
// keeps its helper functions in own scope: makes it clear
// that only 'interestingHighLevelTask' is using them
function interestingHighLevelTask() {

  boringFiddlyHelper();
  moreImplementationDetails();
  // ...


  function boringFiddlyHelper() {
  }
  function moreImplementationDetails() {
  }
}
```
</script></section>




<section data-markdown><script type="text/template">
## Plus de change...

Not everything varies - let your readers (if not the interpreter) know.

```javascript
var A_CONSTANT_VALUE = "something";
var CONSTANTS = {
  NORTH: "north", // don't use numbers please, 
  SOUTH: "south", // trailing commas encouraged - less version-control noise
};

// ES6
const A_CONSTANT_VALUE = "something";
```
</script></section>




<section data-markdown data-state=title><script type="text/template">
## Control-flow
</script></section>


<section data-markdown><script type="text/template">
## Familiar faces

```javascript
for(var i = 0; i < 100; i++) {
}
// remember, not all blocks req'd, and
// can use comma operator to do > 1 thing in each
for(; node; node = node.next) {
}

// length caching: (only for old interpreters)
for(var i=0, len=xs.length; i < len; i++) {
}

while(node = node.next) {
}

do {
} while (node = node.next);
```
</script></section>

<section data-markdown data-state=title><script type="text/template">
## Comparators
</script></section>

<section data-markdown><script type="text/template">
## Yes `==` has issues
</script></section>


<section>
<h2>Comparison</h2>
<p>If you can't be bothered to remember, use <code>===</code>.</p>

<div class=little-console></div>

</section>

<section data-markdown><script type="text/template">
## NaN !== NaN for a reason

- NaN means "category error", it can't meaningfully be equal to anything
- this is why the `isNaN()` exists
</script></section>


<section data-markdown data-state=title><script type="text/template">
## Functions
</script></section>

<section data-markdown><script type="text/template">
## Two ways of defining

```javascript
var fn = function() {};

function another() {};
```
</script></section>

<section data-markdown><script type="text/template">
## Function hoisting is great

```javascript

main(document.querySelector("#something"));

function main(el) {
  var val = otherThing(el);
}

function otherThing() {
  someHelper();

  function someHelper() {
  }
}
```
</script></section>

<section data-markdown><script type="text/template">
## First-class

First class: use wherever you can use other values

```javascript
function doTwice(fn) {
  fn() // fn has been passed in as an argument
  fn()
}

doTwice(function() {
  console.log("Hello!")
})

function doubleFn(fn) {
  return function() { // with FCFs we can return functions
    doTwice(fn)
  }
}

var doubleTalk = doubleFn(function() {
  console.log("I'm going to be saying this twice")
})

doubleTalk()
```
</script></section>

<section data-markdown><script type="text/template">
## FCF = higher order functions

- we can pass functions to functions to functions...

```javascript
function loop(fn) {
  fn()
  loop(fn)
}

loop(function() {
  console.log("We'll be here for some time")
})
```
</script></section>


<section data-markdown><script type="text/template">
## Importance of var

```javascript
var greeting;
var i = 100;

sayHi("javascript","hello",10);

console.log(i);

function sayHi(to,greeting,times) {
  i = times;
  while(i--) {
    console.log("%s %s",greeting,to);
  }
}
```
</script></section>


<section data-markdown><script type="text/template">
## Missing features: default/optional and kwargs

</script></section>

<section data-markdown><script type="text/template">
## Interlude: logical operators

Short-circuit, work on returning operands.

```javascript
var shorts = true || alert("won't see me");
var moreShorts = false && alert("or me");

someVar && doSomething(); // please don't use as control-flow

var oneOrTheOther = one || theOther; // only for assignments
(one || theOther).doSomething(); // or this (within reason)
```
</script></section>

<section data-markdown><script type="text/template">
## Optional implementation

```javascript
function takeOptional(name, greeting) {
  greeting = greeting || "hi";
  
  console.log(greeting + " " + name)
}
              
takeOptional("tom", "hello");
takeOptional("tom");
```
</script></section>

<section data-markdown><script type="text/template">
## kwargs implementation

```javascript
function takeKeywords(name,opts) {
  opts = opts || {};
  greeting = opts.greeting || "hi";
  console.log(greeting + " " + name)
}

takeKeywords("tom");
```
</script></section>

<section data-markdown><script type="text/template">
## Varargs

`arguments`: for each function call.

```javascript
function englishList() {
  var items = [].slice.call(arguments);
  if(items.length <= 2) {
    return items.join(" and ");
  } else {
    var commas = items.slice(0,arguments.length - 1);
    return commas.join(", ") 
      + " and " + items[items.length - 1];
  }
}

function es6EnglishList(words...) {
}
```
</script></section>

<section data-markdown><script type="text/template">
## Many idioms...
</script></section>

<section data-markdown><script type="text/template">
## "Array likes"

- `arguments`, `NodeList`
- subscriptable (`[3] = "foo"` etc), have `.length`
- but don't have `Array.prototype` - e.g `slice`, `indexOf`
- `slice` them to fix - via `[].slice.call` or lib
</script></section>

<section data-markdown><script type="text/template">
## `.call`

JS's FP/OOP hybrid model to thank

```javascript
Function.prototype.call = function(thisValue,args...) {
  // runs the function (this), setting this = thisValue, 
  // and args = args
}

// e.g

[].slice.call(["a","b","c","d"],2) // ["c","d"];
/* some fn */.call(/*this*/,/* arg, ... argN */);

```
</script></section>


<section data-markdown data-state=title><script type="text/template">
## Data-structures
</script></section>

<section data-markdown><script type="text/template">
## Two types
</script></section>

<section data-markdown><script type="text/template">
## Ordered

- `Array`
</script></section>


<section data-markdown><script type="text/template">
## Array

```javascript
// use literals in nearly every case
var anArray = [];

// only one good use for this constructor
var another = new Array(16); 

var joined = anArray.concat([1,2,3]); // non-destructive
var tail = anArray.slice(1);          // non-destructive
anArray.splice(0,1);                  // destructive, can replace

// in-place (stability unspecified)
var ascending = tail.sort(function(a,b) {
  return a - b;
});
```
</script></section>


<section data-markdown><script type="text/template">
## One good use for `new Array`

Avoids resize when length is known.

```sh
> benchmark 'var i = 16, a = []; while(i--) a[i] = i'

One million iterations...

real	0m0.628s
user	0m0.610s
sys	0m0.025s

> benchmark 'var i = 16, a = new Array(16); while(i--) a[i] = i'

One million iterations...

real	0m0.388s
user	0m0.370s
sys	0m0.022s
```
</script></section>

<section data-markdown><script type="text/template">
## Yes - v8 is fast...
</script></section>

<section data-markdown><script type="text/template">
## Key-value
</script></section>

<section data-markdown><script type="text/template">
## Objects, abused as maps

Misses lots of the niceities of a real map.

```javascript
var myMap = {};

myMap["1"] = "hello";
console.log(myMap[1]);

delete myMap[1];

myMap[{}] = {};
console.log(myMap[{}]);
```
</script></section>

<section data-markdown><script type="text/template">
## Map

Coming in ES6, keys via object identity.

```javascript
var myMap = new Map;

var a = {};
myMap.set(a,"hi");
console.log(myMap.get(a));

console.log(myMap.length);
```
</script></section>

<section data-markdown><script type="text/template">
## Set

ES6: when we just care about membership.

```javascript
var set = new Set;

var a = {};
set.add(a);
console.log(set.has(a));
console.log(set.has({}));

console.log(set.length);
```
</script></section>


<section data-markdown><script type="text/template">
## Where can you use?

- IE 11/Chrome/FF only? Now!
- Node - now! (with --harmony)

</script></section>


<section data-markdown data-state=title><script type="text/template">
## The JS object system
</script></section>

<section data-markdown><script type="text/template">
## OOP, hand-rolled

- or more
</script></section>

<section data-markdown><script type="text/template">
## Objects in JS

- Have string properties whose values can be any JS type.

```javascript
var turtle = {x: 10, y: 20};
```
</script></section>

<section data-markdown><script type="text/template">
## Methods

- We want to have a consistent set of methods, with shorthand access to object

```javascript
var move = function(dx,dy) {
  this.x += dx;
  this.y += dy;
};

var turtle = {x: 10, y: 20};
turtle.move = move;
turtle.move(10,10);
```
</script></section>

<section data-markdown><script type="text/template">
## How does this work?

- `someObject.property()` will set `this` to `someObject` while running function returned from `someObject.property`

```javascript
turtle.move(10,10);

// =
turtle.move.call(turtle,10,10);

function move(dx,dy) {
  this.x += dx;
  this.y += dy;
};
```
</script></section>

<section data-markdown><script type="text/template">
## We want constructors

```javascript
function createTurtle(x,y) {
  var turtle = {x: x, y: y, move: turtleMove};
  return turtle;
}

function turtleMove(dx,dy) {
  this.x += dx;
  this.y += dy;
}
```
</script></section>

<section data-markdown><script type="text/template">
## Standardise: constructor

```javascript
function Turtle(x,y) {
  this.x = x; // 'this' ready-allocated
  this.y = y;
  // no return required
}

```
</script></section>

<section data-markdown><script type="text/template">
## Will this work?

```javascript
var aSweetTurtle = Turtle();
```
</script></section>

<section data-markdown><script type="text/template">
## `new` is the power

```javascript
function Turtle(x,y) {
  this.x = x;
  this.y = y;
}

// clear that new is not a standard fn call
var aSweetTurtle = new Turtle;
```
</script></section>

<section data-markdown><script type="text/template">
## Sharing methods

```javascript
function Turtle(x,y) {
  this.x = x;
  this.y = y;
}

Turtle.prototype.move = function(dx,dy) {
  this.x += dx;
  this.y += dy;
};
```
</script></section>

<section data-markdown><script type="text/template">
## Prototype chains

- Objects are bags of properties
- `object.property` asks for value of `property`
- If `object` lacks property, we restart questioning at `object.prototype`
- Once we've run out of prototypes (`O.pt.pt`) we get `undefined`
</script></section>


<section data-markdown><script type="text/template">
## `new` operator

```javascript
function Turtle(x,y) {
  this.x = x;
  this.y = y;
}

Turtle.prototype.move = function(dx,dy) {
  this.x += dx;
  this.y += dy;
};

function newOperator(constructor) {
  var instance = Object.create(constructor.prototype);
  var returnVal = constructor.apply(instance,slice(arguments,1));
  return typeof returnVal == "object" ? returnVal : instance;
}
```
</script></section>

<section data-markdown><script type="text/template">
## `new`'s final trick

```javascript
function Turtle(x,y) {
  this.x = x;
  this.y = y;
  return { haha: "didn't expect this" };
}

var turtle = new Turtle;
console.log(turtle.haha);
```
</script></section>

<section data-markdown><script type="text/template">
## Useful

- Refactor constructor to factory
- Quite powerful voodoo
</script></section>


<section data-markdown><script type="text/template">
## Sneaky trick

```javascript
function User(id) {
  this.id = id;
}

User.prototype.toString = function() {
  return "User<" + this.id + ">";
}

var userScores = {};
var tim = new User("tim");
var sarah = new User("sarah");

userScores[tim] = 10;
userScores[sarah] = 20;

console.log(userScores[tim]) // 10
```
</script></section>


<section>
<h2>Property descriptors</h2>
<p>Add properties and control writes/modification</p>

<script type=console-setup>
  durations = {};

  Object.defineProperties(durations,{
    hour: {
      value: 3600 * 1000,
      writable: false
    }
  });
</script>
<div class=little-console></div>

<script type=cheat>
</script>

</section>

<section data-markdown><script type="text/template">
## Safe(er) monkey patch

```javascript
Object.defineProperty(Object.prototype,"awesomeify",{
  enumerable: false,
  value: function() {
    this.awesome = true;
  }
});

var anObject = [];
anObject.awesomeify();
anObject.awesome // true

var props = [];
for(var prop in anObject) props.push(prop);
console.log(props.length) // 0
```
</script></section>

<section data-markdown><script type="text/template">
## Preventing change

All shallow

```javascript
Object.preventExtension // can't add properties
Object.seal             // above, + can't configure properties
Object.freeze           // immutable

Object.is{Extensible,Sealed,Frozen} // check
```
</script></section>


<section data-markdown><script type="text/template">
## Strict mode

No `with`.

```javascript
var someVar = 10;
spmeVar = 20 // catches typos, rather than adding globals!

var constants = {};
Object.freeze(constants);
constants.foo = "bar"; // throws, rather than silently failing

var withDupes = {a: 1, a: 2};

eval("b = 'howdy'");
console.log(typeof b) // 'undefined'
```

</script></section>


<section data-markdown data-state=title><script type="text/template">
## OOP in JS
</script></section>

<section data-markdown><script type="text/template">
## Use prototypes

```javascript
function ClassName() {
}

ClassName.prototype = {
};
ClassName.constructor = ClassName;
```
</script></section>

<section data-markdown><script type="text/template">
## Inheritance

There are edge-cases if you do lots of work in constructor - this is gist, but use a library.

```javascript
function ClassName(arg,subClassArg) {
  SuperClass.call(this,arg);
}

ClassName.prototype = new SuperClass;
ClassName.constructor = ClassName;
```
</script></section>

<section data-markdown><script type="text/template">
## Calling 'super'

Could add a `__super__` to prototype.

```javascript
ClassName.prototype.something = function(arg1,argN) {
  SuperClass.prototype.something.call(this,arg1,argN);
}
```
</script></section>


<section data-markdown><script type="text/template">
## Composition over inheritance
</script></section>


<section data-markdown><script type="text/template">
## Example

Inheritance is very tight coupling: many reasons to change.

```javascript
Widget > Table > PagedTable > EditablePagedTable
```
</script></section>

<section data-markdown><script type="text/template">
## Via composition

```javascript
function PagedTable(el,table) {
  var pagerWidget = new PagerWidget;
  el.appendChild(pagerWidget.el);
  el.appendChild(table.el);
}
```
</script></section>


<section data-markdown><script type="text/template">
## Duck typing
</script></section>

<section>
<h2>Duck-typing</h2>

<p>In classical OOP languages, you can `isA` check for supertypes/interfaces</p>

<script type=console-setup>
  TypeA = function() {}
  TypeB = function() {}
  TypeB.prototype = new TypeA;
</script>

<div class=little-console></div>

</section>


<section data-markdown><script type="text/template">
## Works ok

```javascript
var X = Backbone.Model.extend();
var x = new X;

console.log(x instanceof Backbone.Model);
```
</script></section>


<section data-markdown><script type="text/template">
## But... inflexible

- must have that constructor in prototype chain
- harder to reuse code
- much harder to test (passing mocks/stubs)
</script></section>

<section data-markdown><script type="text/template">
## Duck type!

```javascript
function withModel(model) {
  // determine objects 'type' via checking its API,
  // rather than how it got its API (prototype chain)
  if(typeof model.get === "function") {

  } else if(typeof model.get === "string") {

  }
}
```
</script></section>

<section data-markdown data-state=title><script type="text/template">
## Quirks
</script></section>


<section data-markdown><script type="text/template">
```javascript
if(new Boolean(false)) {
  console.log("this is why we avoid new Boolean");
}

if(Boolean(1)) {
  console.log("Good way to coerce to boolean");
}

if(!!unknown) {
  console.log("Another - perhaps less explicit");
}

if(new String("hi") !== "hi") {
  console.log("ugh - just avoid object wrappers for 'primitives'");
}

if((3.14159).toFixed(5) === "3.14159") {
  console.log("there is no benefit to object wrappers: the 'primitives'" +
     " still have access to prototype methods");
}
```
</script></section>

<section data-markdown><script type="text/template">
## Fin!
</script></section>

</div>
</div>



<script src=slides-theme/js/code-example.js></script>
<script>
  function revealCodeSamples() {
    codeExamples.reveal("script[type=code-example-alongside]");
    codeExamples.reveal("script[type=console-setup]");
    [].forEach.call(document.querySelectorAll("script[type=console-setup]"),function(el) {
      eval(el.innerHTML);
    });
  }
</script>

<script src=slides-theme/js/little-console.js></script>
<script>
  function showConsoles() {

    // show all consoles, and register 'cheats'
    var cheats = [];

    ;[].forEach.call(document.querySelectorAll(".little-console"),function(el) {
      var cmds = new LittleConsole.Commands;
      var console = new LittleConsole({el: el,commands: cmds});
      var slide = el.parentElement;
      var cheat = slide.querySelector("[type=cheat]");
      if(!cheat) return;
      cheats.push({
        console: console,
        slide: slide,
        src: cheat.innerHTML,
      });
    });

    // listen for 'cheat code' - ALT + C, and fill input
    var C = 67;
    document.body.addEventListener("keyup",function(evt) {
      if(evt.keyCode !== C || !evt.altKey) return;
      var slide = Reveal.getCurrentSlide();
      cheats.forEach(function(setup) {
        if(setup.slide !== slide) return;
        setup.console.setCommand(setup.src);
      });

    });

  }
</script>

<script src="reveal/lib/js/head.min.js"></script>
<script src="reveal/js/reveal.min.js"></script>
<script>
  Reveal.initialize({

    // Display controls in the bottom right corner
    controls: false,

    // Display a presentation progress bar
    progress: true,

    // Push each slide change to the browser history
    history: true,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    center: false,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Apply a 3D roll to links on hover
    rollingLinks: false,

    // Transition style
    transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none

    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interreveal/pret Markdown in <section> elements
        { src: 'reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal/plugin/markdown/markdown.js', 
          condition: function() { return !!document.querySelector( '[data-markdown]' ); },
          callback: function() {
            revealCodeSamples(); 
            showConsoles();
          } },

        // Syntareveal/x highlight for <code> elements
        { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Zoom reveal/in and out with Alt+click
        { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speakreveal/er notes
        { src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remotreveal/e control your reveal.js presentation using a touch device
        // { src: 'reveal/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
    ]

  });
</script>
</body>


